package at.archistar.crypto;

import at.archistar.crypto.data.Share;
import at.archistar.crypto.data.Share.Type;
import at.archistar.crypto.exceptions.ReconstructionException;
import at.archistar.crypto.exceptions.WeakSecurityException;
import at.archistar.crypto.math.CustomMatrix;
import at.archistar.crypto.math.GF256;
import at.archistar.crypto.math.GF256Polynomial;
import at.archistar.crypto.math.PolyGF256;
import at.archistar.crypto.random.RandomSource;
import at.archistar.helper.ByteUtils;

/**
 * @author Elias Frantar <i>(improved Exception handling)</i>
 * @author Andreas Happe <andreashappe@snikt.net>
 * @author Fehrenbach Franca-Sofia
 * @author Thomas Loruenser <thomas.loruenser@ait.ac.at>
 */
public class ShamirPSS extends SecretSharing {

    final private RandomSource rng;

    public ShamirPSS(int n, int k, RandomSource rng) throws WeakSecurityException {
        super(n, k);
        
        this.rng = rng;
    }

    @Override
    public Share[] share(byte[] data) {
    	//Create shares
        Share shares[] = new Share[n];
        for (int i = 0; i < n; i++) {
            shares[i] = new Share(i + 1, data.length, Type.SHAMIR);
        }

        int a[] = new int[k];
        for (int i = 0; i < data.length; i++) {
            //Let a[0] be the secret (as a byte)
            a[0] = (data[i] < 0) ? (data[i] + 256) : data[i];

            //Every other coefficient is a randomly generated byte
            for (int j = 1; j < k; j++) {
                a[j] = rng.generateByte();
            }

            GF256Polynomial poly = new GF256Polynomial(a);

            //Calculate the share for this (source)byte for every share
            for (int j = 0; j < n; j++) {
                shares[j].yValues[i] = (byte) (poly.evaluateAt(shares[j].xValue) & 0xFF);
            }
        }

        return shares;
    }

    @Override
    public byte[] reconstruct(Share[] shares) throws ReconstructionException {
    	if (!validateShareCount(shares.length, k)) {
    		throw new ReconstructionException();
    	}
    	
    	try {
	        int xValues[] = new int[shares.length];
	        byte result[] = new byte[shares[0].yValues.length];
	
	        for (int i = 0; i < shares.length; i++) {
	            xValues[i] = shares[i].xValue;
	        }
	
	        CustomMatrix decodeMatrix = PolyGF256.erasureDecodePrepare(xValues);
	        int[] decodeVector = decodeMatrix.getRow(0);
	
	        for (int i = 0; i < shares[0].yValues.length; i++) {
	
	            int yValues[] = new int[shares.length];
	            for (int j = 0; j < shares.length; j++) {
	                yValues[j] = ByteUtils.toUnsignedByte(shares[j].yValues[i]); // we may only pass unsigned bytes to GF256
	            }
	
	            int tmp = 0;
	            for (int j = 0; j < yValues.length; j++) {
	                tmp = GF256.add(tmp, GF256.mult(yValues[j], decodeVector[j]));
	            }
	            result[i] = (byte) (tmp & 0xFF);
	        }
	
	        return result;
    	} catch (Exception e) { // if anything goes wrong during reconstruction, throw a ReconstructionException
    		throw new ReconstructionException();
    	}
    }
}
