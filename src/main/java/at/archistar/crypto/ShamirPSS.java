package at.archistar.crypto;

import java.security.GeneralSecurityException;

import at.archistar.crypto.data.Share;
import at.archistar.crypto.data.Share.Type;
import at.archistar.crypto.exceptions.ReconstructionException;
import at.archistar.crypto.exceptions.WeakSecurityException;
import at.archistar.crypto.math.CustomMatrix;
import at.archistar.crypto.math.GF256;
import at.archistar.crypto.math.GF256Polynomial;
import at.archistar.crypto.math.PolyGF256;
import at.archistar.crypto.random.RandomSource;
import at.archistar.helper.ByteUtils;

/**
 * @author Andreas Happe <andreashappe@snikt.net>
 * @author Fehrenbach Franca-Sofia
 * @author Thomas Loruenser <thomas.loruenser@ait.ac.at>
 */
public class ShamirPSS implements SecretSharing {

    final private int n;

    final private int k;

    final private RandomSource rng;

    public ShamirPSS(int n, int k, RandomSource rng) {
        this.n = n;
        this.k = k;
        this.rng = rng;
    }

    @Override
    public Share[] share(byte[] data) throws WeakSecurityException {

        if (k < 2) {
            throw new WeakSecurityException();
        }

        //Create shares
        Share shares[] = new Share[n];
        for (int i = 0; i < n; i++) {
            shares[i] = new Share(i + 1, data.length, Type.SHAMIR);
        }

        int a[] = new int[k];
        for (int i = 0; i < data.length; i++) {
            //Let a[0] be the secret (as a byte)
            a[0] = (data[i] < 0) ? (data[i] + 256) : data[i];

            //Every other coefficient is a randomly generated byte
            for (int j = 1; j < k; j++) {
                a[j] = rng.generateByte();
            }

            GF256Polynomial poly = new GF256Polynomial(a);

            //Calculate the share for this (source)byte for every share
            for (int j = 0; j < n; j++) {
                shares[j].yValues[i] = (byte) (poly.evaluateAt(shares[j].xValue) & 0xFF);
            }
        }

        return shares;
    }

    @Override
    public byte[] reconstruct(Share[] shares) throws ReconstructionException, GeneralSecurityException {
    	if (shares.length < k) {
    		throw new ReconstructionException();
    	}
    	
        int xValues[] = new int[shares.length];
        byte result[] = new byte[shares[0].yValues.length];

        for (int i = 0; i < shares.length; i++) {
            xValues[i] = shares[i].xValue;
        }

        int[] decodeVector = {};
        try {
            CustomMatrix decodeMatrix = PolyGF256.erasureDecodePrepare(xValues);
            decodeVector = decodeMatrix.getRow(0);
        } catch (ReconstructionException ex) {
            ex.printStackTrace();
        }

        for (int i = 0; i < shares[0].yValues.length; i++) {

            int yValues[] = new int[shares.length];
            for (int j = 0; j < shares.length; j++) {
                yValues[j] = ByteUtils.toUnsignedByte(shares[j].yValues[i]); // we may only pass unsigned bytes to GF256
            }

            int tmp = 0;
            for (int j = 0; j < yValues.length; j++) {
                tmp = GF256.add(tmp, GF256.mult(yValues[j], decodeVector[j]));
            }
            result[i] = (byte) (tmp & 0xFF);
        }

        return result;
    }

}
