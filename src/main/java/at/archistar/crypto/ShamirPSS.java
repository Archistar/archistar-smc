package at.archistar.crypto;

import at.archistar.crypto.data.ShamirShare;
import at.archistar.crypto.data.Share;
import at.archistar.crypto.exceptions.ReconstructionException;
import at.archistar.crypto.exceptions.WeakSecurityException;
import at.archistar.crypto.math.CustomMatrix;
import at.archistar.crypto.math.GF256;
import at.archistar.crypto.math.GF256Polynomial;
import at.archistar.crypto.math.PolyGF256;
import at.archistar.crypto.random.RandomSource;
import at.archistar.helper.ByteUtils;

/**
 * @author Elias Frantar <i>(improved Exception handling)</i>
 * @author Andreas Happe <andreashappe@snikt.net>
 * @author Fehrenbach Franca-Sofia
 * @author Thomas Loruenser <thomas.loruenser@ait.ac.at>
 */
public class ShamirPSS extends SecretSharing {

    final private RandomSource rng;

    public ShamirPSS(int n, int k, RandomSource rng) throws WeakSecurityException {
        super(n, k);
        
        this.rng = rng;
    }

    @Override
    public Share[] share(byte[] data) {
    	//Create shares
        ShamirShare shares[] = new ShamirShare[n];
        for (int i = 0; i < n; i++) {
            shares[i] = new ShamirShare((byte) (i + 1), new byte[data.length]);
        }

        int a[] = new int[k];
        for (int i = 0; i < data.length; i++) {
            //Let a[0] be the secret (as a byte)
            a[0] = ByteUtils.toUnsignedByte(data[i]);

            //Every other coefficient is a randomly generated byte
            for (int j = 1; j < k; j++) {
                a[j] = rng.generateByte();
            }

            GF256Polynomial poly = new GF256Polynomial(a);

            //Calculate the share for this (source)byte for every share
            for (int j = 0; j < n; j++) {
                shares[j].getY()[i] = (byte) (poly.evaluateAt(shares[j].getId()));
            }
        }

        return shares;
    }

    @Override
    public byte[] reconstruct(Share[] shares) throws ReconstructionException {
    	if (!validateShareCount(shares.length, k)) {
    		throw new ReconstructionException();
    	}
    	
    	try {
    		ShamirShare[] sshares = safeCast(shares); // we need access to the attributes in ShamirShare
    		
	        int xValues[] = new int[sshares.length];
	        byte result[] = new byte[sshares[0].getY().length];
	
	        for (int i = 0; i < shares.length; i++) {
	            xValues[i] = sshares[i].getId();
	        }
	
	        CustomMatrix decodeMatrix = PolyGF256.erasureDecodePrepare(xValues);
	        int[] decodeVector = decodeMatrix.getRow(0);
	
	        for (int i = 0; i < result.length; i++) {
	
	            int yValues[] = new int[sshares.length];
	            for (int j = 0; j < sshares.length; j++) {
	                yValues[j] = ByteUtils.toUnsignedByte(sshares[j].getY()[i]); // we may only pass unsigned bytes to GF256
	            }
	
	            int tmp = 0;
	            for (int j = 0; j < yValues.length; j++) {
	                tmp = GF256.add(tmp, GF256.mult(yValues[j], decodeVector[j]));
	            }
	            result[i] = (byte) (tmp & 0xFF);
	        }
	
	        return result;
    	} catch (Exception e) { // if anything goes wrong during reconstruction, throw a ReconstructionException
    		throw new ReconstructionException();
    	}
    }

    /**
     * Converts the Share[] to a ShamirShare[] by casting each element individually.
     * 
     * @param shares the shares to cast
     * @return the given Share[] as ShamirShare[]
     * @throws ClassCastException if the Share[] did not (only) contain ShamirShares
     */
    private ShamirShare[] safeCast(Share[] shares) {
    	ShamirShare[] sshares = new ShamirShare[shares.length];
    	
    	for (int i = 0; i < shares.length; i++) {
    		sshares[i] = (ShamirShare) shares[i];
    	}
    	
    	return sshares;
    }
}
